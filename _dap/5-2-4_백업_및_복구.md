---
title: 제4절 백업 및 복구
nav_order: 4
parent: 제2장 데이터베이스 이용
grand_parent: 과목5 데이터베이스 설계와 이용
toc: true
toc_label: "Contents"
---

데이터베이스는 전산 장비의 고장이나 사고에 대비하여 주기적인 백업을 실시하고 장애의 원인을 해결한 후 데이터베이스를 복구해야 한다. 데이터베이스 관리 시스템은 데이터베이스가 파괴되거나 실행이 중단되었을 경우 복구할 수 있는 기능을 제공한다. 비즈니스 영속성 요구 수준에 따라 제공된 기능을 활용하거나 추가적인 비용을 투자하여 대비를 해야 한다. 본 절은 데이터베이스의 기능을 중심으로 백업 및 복구에 대한 설명한다.

## 1. 장애 유형

장애 원인에 따라서 데이터베이스 기능에 의해서 자연 복구되거나 장애에 대비한 백업 전략에 의해 백업 매체를 통해 복구가 가능한 것도 있다.

  * 사용자 실수

사용자 실수로 테이블의 삭제하거나 잘못된 트랜잭션 처리로 데이터의 일관성에 문제가 되는 경우이다. 이는 운영자의 충분한 교육으로 사전에 대비를 충분히 이루어져야 한다. 이런 종류의 장애가 발생했다면 백업된 파일을 이용하여 복구한다.

  * 미디어 장애

하드웨어 장애는 CPU, 메모리, 디스크 등 다양하게 발생할 수 있다. 단순한 하드웨어 장애는 하드웨어 교체로 문제를 해결할 수 있지만 미디어 장애는 데이터가 파손되는 장애이다. 대표적인 것이 하드디스크에 장애가 발생하거나 데이터 파일이 파손되는 경우이다. 주기적 또는 실시간으로 백업을 실시하거나 하드디스크 밀러링으로 이에 대비한다. 장애 발생시는 백업 파일을 이용하여 복구를실시한다.

  * 구문 장애

구문 장애는 프로그램 오류나 사용 용량이 부족하거나 여유 공간이 부족하여 발생하는 장애이다.

  * 사용자 프로세스 장애

사용자 프로그램이 비정상 종료되거나 네트워크 이상으로 세션이 종료되므로 발생하는 오류이다.

이는 데이터베이스 기능에 의해서 복구 처리가 된다.

  * 인스턴스 장애

시스템이 비정상적인 요인으로 메모리나 데이터베이스 서버 프로세스가 중단된 경우를 말한다. 하드웨어 장애, 정전, 시스템 파일 파손 등으로 발생할 수 있다. 이 경우는 물리적인 장애 요소를 제거하고 데이터베이스를 재기동하면 롤포워드와 롤백을 수행하여 인스턴스를 복구한다.

## 2. 로그 파일

로그 파일은 데이터베이스에서 처리되는 트랜잭션의 내용을 모두 기록한 것으로 데이터베이스 복구를 위한 가장 기본적인 매체이다. 이를 매체를 사용하여 데이터베이스를 과거의 상태로 복귀시키거나 또는 과거의 상태로부터 현재 상태로 재생성 할 수 있다.

  * 로그 파일 기록 시기

로그 파일은 다음과 같은 작업이 발생될 때 기록된다.

  * 트랜잭션 시작시점

  * 데이터의 입력, 수정, 삭제 시점

  * 트랜잭션 rollback 시점

  * 로그 파일 내용

  * 로그 파일은 트랜잭션이 발생할 때마다 COMMIT이나 ROLLBACK에 관계없이 모든 내용을 기록한다.

  * 트랜잭션 식별

  * 트랜잭션 레코드

  * 데이터 식별자

  * 갱신 이전 값(Before Image)

  * 갱신 이후 값(After Image)

  * 로그 파일 보관

로그 파일은 로그 버퍼 내용을 Flat-file 형식으로 기록한다. 이는 데이터베이스가 운영 중에는계속해서 생성된다. 따라서 로그 파일을 저장 매체(테이프)로 영구 보관하는 것이 일반적이다.

## 3. 데이터베이스 복구 알고리즘

트랜잭션 실행 내용인 데이터베이스 버퍼를 저장매체에 동기적으로 기록하는 것을 동기적 갱신(Synchronous I/O)라 하고 트랜잭션이 완료된 내용을 일정 시간이나 작업량에 따라 시간 차이를 두고 데이터베이스 버퍼 내용을 저장 매체에 기록하는 것을 비동기적 갱신(Asynchronous I/O)라 한다. 장애가 발생하여 시스템을 재기동 했을 때는 로그 파일을 이용하여 유효한 트랜잭션 처리 데이터를 복구해야 한다. 따라서 동기적/비동기적 갱신에 의해서 데이터베이스 복구 알고리즘이 분류 된다.

  * NO-UNDO/REDO

데이터베이스 버퍼의 내용을 비동기적으로 갱신한다는 의미는 트랜잭션이 성공적으로 수행되어 완료점에 도달할 때까지 데이터베이스 변경 내용이 기록되지 않는다는 것을 의미한다. 즉, 트랜잭 션이 완료되기 이전에는 변경 내용이 데이터베이스에 기록되지 않으므로 완료되지 않은 트랜잭션 은 취소할 필요가 없다. 그러나 트랜잭션이 완료된 후 데이터베이스 버퍼에 기록되고 저장 매체에 기록되지 않는 상태에서 시스템이 파손되었다면 트랜잭션의 내용을 재실행해야 한다. 이러한 방식 의 알고리즘을 NO-UNDO/REDO 복구 알고리즘이라 한다.

  * UNDO/NO-REDO

데이터베이스 버퍼의 내용을 동기적 갱신하는 경우 트랜잭션이 완료되기 전에 데이터베이스 버퍼 내용을 모두 동시적으로 기록하므로 완료된 트랜잭션들은 어떤 연산도 재실행할 필요가 없다. 그 러나 트랜잭션들이 완료되기 이전에 시스템 파손이 발생할 경우 변경된 내용을 취소해야 한다. 이 러한 방식의 알고리즘을 UNDO/NO-REDO 복구 알고리즘이라 한다.

  * UNDO/REDO

데이터베이스 버퍼의 내용을 동기/비동기적으로 갱신할 경우 모든 갱신이 데이터베이스에 기록되 기 전에 트랜잭션이 완료될 수 있으므로 완료된 트랜잭션이 데이터베이스에 기록되지 못했다면 재 실행을 해야 한다. 이러한 방식의 알고리즘을 UNDO-REDO 복구 알고리즘이라고 한다. 이 복구 방법은 가장 일반적인 기법이지만 가장 복잡한 기법이기도 하다.

  * NO-UNDO/NO-REDO

데이터베이스 버퍼 내용을 동시적으로 저장 매체에 기록하나 데이터베이스와는 다른 영역에 기록 하는 경우이다. 항상 트랜잭션의 실행 상태와 데이터베이스의 내용이 일치하며, 따라서 데이터베 이스 버퍼의 내용을 취소하거나 재실행할 필요가 없다. 이러한 방식의 알고리즘을 NOUNDO/ NO-REDO 복구 알고리즘이라고 한다.

## 4. 백업 종류

데이터베이스 백업은 장애 시 복구를 위한 작업이다. 따라서 복구 수준에 따라서 백업의 종류가 결 정된다. 데이터베이스 백업은 운영체제를 이용한 물리 백업과 DBMS에서 제공한 유틸리티를 이용한 논리 백업으로 나뉜다.

[표 5-2-3] 백업 종류

| 구분 | 설명 | 복구 수준 |
|----|----|----|
|물리 백업 | 로그 파일 백업 실시 | 완전 복구 |
| 로그 파일 백업 없음|백업 시점까지 복구 |
| 논리 백업 | DBMS 유틸리티 |

## 5. 데이터베이스 백업 가이드 라인

  * 정기적인 Full-backup을 수행한다.

  * 데이터베이스 구조적 변화가 생긴 전후 Full-backup을 수행한다.

  * 테이블 스페이스의 생성 또는 삭제

  * 테이블 스페이스에 데이터 파일을 추가하거나 변경했을 때

  * Log 파일을 변경했을 때

  * Archive Log Mode로 전환 시 Control 파일만이라도 백업을 실시하며, No-archive log mode로 전환할 때는 Full backup을 수행함

  * Read-write 수행이 많은 테이블스페이스는 자주 온라인 백업을 실시함

  * 백업 파일은 2본 이상을 보유한다. Incomplete Recovery를 용이하게 함

  * 논리 백업은 특정 데이터 또는 특정 테이블 오류 시 복구가 용이함

  * 분산 데이터베이스는 동일 모드에서 백업을 수행함

  * Read-only 테이블 스페이스는 온라인 백업할 필요가 없다.

  
# 장 요약
  
* 제1절 데이터베이스 관리시스템(DBMS)
  * DBMS 서버는 인스턴스와 데이터베이스로 구성되어 있다.
  * 인스턴스는 메모리 부문와 프로세스 부문으로 구성된다.
  * 데이터베이스 관리 시스템은 데이터의 저장 구조를 논리적인 구조와 물리적인 구조로 나누어 관리한다..

* 제2절 데이터 액세스
  * SQL 질의는 파싱, 옵티마이저, 로우 소스 생성, SQL 실행 등과 같은 4단계를 거쳐 수행된다.
  * 데이터베이스 명령어는 데이터 정의 언어(DDL), 데이터 조작 언어(DML), 제어 명령어(Control Statements)로 나눌 수 있다.

* 제3절 트랜잭션
  * 트랜잭션은 원자성, 일관성, 고립성, 영속성의 특성이 있다.
  * 동시성 제어는 낙관적 동시성 제어(Optimistic Concurrency Control)와 비관적 동시성 제어(Pessimistic Concurrency Control)로 나뉜다.
  * 동시성을 제어하기 위해 잠김(Locking), 2PC, Timestamp 등의 기법을 주로 사용한다.
  * 교착 상태는 교착 상태 필수 조건 4가지를 부정함으로써 교착 상태를 예방할 수 있다.

* 제4절 백업 및 복구
  * 복구 전략에 의해 백업 방법을 결정하고 장애 시에 백업 매체를 통해 복구를 수행한다.
  * 복구는 데이터베이스 버퍼를 저장 매체에 동기적으로 기록하느냐 비동기적으로 기록하느냐에 따라 NO-UNDO/REDO, UNDO/NO-REDO, UNDO/REDO, NO-UNDO/NO-REDO 등과 같은 방법으로 복구가 이루어질 수 있다.

# 연습문제

### 문제 1. 다음 중 데이터베이스 서버의 시작과 종료에 관한 설명으로 틀린 것은?
  * [ ] ① 데이터베이스를 사용하기 위해서는 권한을 가진 데이터베이스 관리자가 DBMS 인스턴스를 시작해야 한다.
  * [ ] ② 인스턴스 시작은 매개변수 파일을 읽어 초기화 매개변수 값을 결정하고, 데이터베이스 정보를 위해서 사용되는 메모리 공유 영역을 할당한 뒤 자동 복구 작업, 미확정 분산 트랜잭 해결작업을 수행한다. 
  * [ ] ③ 데이터베이스가 마운트(Mount)되더라도 데이터베이스는 여전히 닫힌 상태이며 데이터베이스 관리자만이 액세스 할 수 있다.
  * [x] ④ 데이터베이스 서버종료는 데이터베이스 닫기, 마운트 해제, 인스턴스 종료 순으로 진행된다.
> 자동 복구 작업, 미확정 분산 트랜잭션 해결, 읽기 전용 모드의 보수작업 등은 데이터베이스 열기단계에서 수행되는 작업들이다.
  
### 문제 2. 다음 중 SQL문의 실행 단계에 대한 설명으로 틀린 것은?
  * [ ] ① 파싱 단계는 구문과 의미 검사를 수행한다. 
  * [ ] ② 옵티마이저 단계는 파싱 단계에서 넘겨받은 결과를 이용하여 파싱 트리를 구성한다. 
  * [x] ③ 로우 소스 생성 단계는 테이블 액세스 방법, 조인 방법, 정렬 등을 위한 다양한 로우 소스가 제공된다. 
  * [ ] ④ SQL 실행 단계는 SQL 엔진에서 수행한 결과를 사용자에게 돌려주는 과정이다.
> 파싱 트리가 구성되는 단계는 파싱 단계이고 옵티마이저 단계에서는 파싱 트리를 이용하여 최적의실행 계획을 고르는 일을 한다.
  
### 문제 3. 다음 중 로우 소스 생성 단계에 대한 설명으로 바른 것은?
  * [x] ① SQL 구문을 파싱 트리 형태로 변형한다. 
  * [ ] ② 파싱 트리를 이용하여 최적의 실행 계획을 선택한다. 
  * [ ] ③ SQL 수행 엔진에서 수행한 결과를 사용자에게 돌려준다. 
  * [ ] ④ 옵티마이저에서 넘겨받은 실행 계획을 내부적으로 처리하는 자세한 방법을 생성하는 단계이다.
> 파싱 단계 : SQL 구문을 파싱 트리 형태로 변형한다.
> 옵티마이저 단계 : 파싱 트리를 이용하여 최적의 실행계획을 선택한다.
> SQL 실행 단계 : SQL 수행 엔진에서 수행해서 결과를 사용자에게 돌려준다.
  
### 문제 4. 다음 중 트랜잭션의 고립성에 대한 설명으로 바른 것은?
  * [ ] ① 계좌 이체 시 송신 계좌의 출금과 수신 계좌의 입금은 전체가 완전하게 수행되어야 한다. 
  * [ ] ② 프로그래머나 무결성 제약 조건을 시행하는 DBMS에서 처리된다. 
  * [x] ③ 변경이 완료되면 그 결과는 이후의 어떠한 고장에도 손실되지 않아야 한다. 
  * [ ] ④ 갱신에 따른 손실이 없어야 하며 모순 판독이 없고 반복 읽기 성질을 갖는다.
> 원자성 : 계좌이체 시 송신 계좌의 출금과 수신 계좌의 입금은 전체가 완전하게 수행되어야 한다.
> 일관성 : 프로그래머나 무결성 제약 조건을 시행하는 DBMS에서 처리된다.
> 영속성 : 변경이 완료되면, 그 결과는 이후의 어떠한 고장에도 손실되지 않아야 한다.
> 고립성 : 갱신에 따른 손실이 없어야 하며 모순판독이 없고 반복 읽기 성질을 갖는다.
  
### 문제 5. 다음 중 데이터베이스의 복구 알고리즘 중 NO-UNDO/REDO에 대한 설명으로 바른 것은?
  * [ ] ① 데이터베이스 버퍼의 내용을 비동기적으로 갱신하는 복구 알고리즘이다. 
  * [ ] ② 데이터베이스 버퍼의 내용을 동기/비동기적으로 갱신하는 복구 알고리즘이다. 
  * [ ] ③ 데이터베이스 버퍼의 내용을 비동기 동기적으로 갱신하는 복구 알고리즘이다. 
  * [x] ④ 데이터베이스 버퍼의 내용을 동기적으로 갱신하는 복구 알고리즘이다.
> NO-UNDO/REDO : 데이터베이스 버퍼의 내용을 비동기적으로 갱신하는 복구 알고리즘이다.

